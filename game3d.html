<!doctype html>
<html>
   <body>
      <canvas width = "570" height = "570" id = "my_Canvas"></canvas>

      <script>

var pXCell=0;
var pZCell=0;
function crossProduct(a,b){
    return new vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);
}
function dotProduct(a,b){
    return a.x*b.x+a.y*b.y;
}
function transposed(m){
   var result=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
   for(var i=0;i<4;i++){
      for(var j=0;j<4;j++){
         result[i*4+j]=m[j*4+i];
      }
   }
   return result;
}

function multMat4sAsArrays(mat1,mat2){
   var result=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
   //assume row major for now
   for(var i=0;i<4;i++){
      for(var j=0;j<4;j++){
         var resIndex=i*4+j;
         var total = 0;
         for(var k=0;k<4;k++){
            mat1Index=i*4+k;
            mat2Index=k*4+j;
        
            total=total+mat1[mat1Index]*mat2[mat2Index];
         }
         result[resIndex]=total;
      }
   }
   return result;
}
var keyArray={};

const Keys = {'a':65,'s':83,'w':87,'d':68,'left':37,'right':39,'down':40,'up':38,'escape':27,'space':32};

function onKeyDown(event)
{

    keyArray[event.keyCode]=true;

}

function onKeyUp(event)
{

    keyArray[event.keyCode]=false;
  
}

function isKeyDown(key)
{
    return keyArray[key]===true;
}

window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);

class material3{
   sourceCode="\nfinalColor=vec3(0,0,0);\n";
   uniforms=[]
   constructor(sourceCode,colorAssignment,uniforms){
      this.sourceCode=sourceCode;
      this.colorAssignment=colorAssignment;
      if(uniforms!==undefined){
         this.uniforms=uniforms;
      }
   }
   getFullSource(){
     
      return `if(vColor.x==${this.colorAssignment.x.toFixed(4)}&&vColor.y==${this.colorAssignment.y.toFixed(4)}&&vColor.z==${this.colorAssignment.z.toFixed(4)}){${this.sourceCode}}\n`;
   }

}
class mazeMesh{ //square
 
   subunitScale=5;
   quads=[]
   height=5;
   constructor(size,maze,subunitScale,height){ //maze: row major, 1=open, 0=occupied
      this.size=size;
      this.maze=maze;
   
      if(typeof subunitScale==='number')
       this.subunitScale=subunitScale;
       if(typeof height==='number')
       this.height=height;
   }
   queryMaze(i,j,di,dj){
      var size=this.size;
      if(typeof di!=='number')
      di=0;
      if(typeof dj!=='number')
      dj=0;

      if(i+di>size-1||i+di<0)
      return 0;
      if(j+dj>size-1||j+dj<0)
      return 0;

      return this.maze[(i+di)*size+(j+dj)];
   }
   build(){
      var size=this.size;
      var subunitScale=this.subunitScale;
      var floor = Math.floor;
      var height=this.height;
     while(this.quads.length>0)
     this.quads.pop();

      for(var i=0;i<size;i++){
         for(var j=0;j<size;j++){
            if(this.queryMaze(i,j)==0)
            continue;

            var worldXCell = j-floor(size/2.0);
         
            var worldZCell = floor(size/2.0)-i;
            if(Math.abs(worldZCell-pXCell)<=3&&Math.abs(worldXCell-pZCell)<=3){

            } else{
               continue;
            }
      

            var worldOffset= new vec3((j-floor(size/2))*subunitScale*2,0,(floor(size/2)-i)*subunitScale*2);

            if(this.queryMaze(i,j,-1,0)==0)
            this.quads.push(new quad3(new vec3(-subunitScale,height,subunitScale).translate(worldOffset),new vec3(subunitScale,height,subunitScale).translate(worldOffset),new vec3(subunitScale,0,subunitScale).translate(worldOffset),new vec3(-subunitScale,0,subunitScale).translate(worldOffset),new vec3(1,0,1)));
            
            if(this.queryMaze(i,j,1,0)==0)
            this.quads.push(new quad3(new vec3(-subunitScale,height,-subunitScale).translate(worldOffset),new vec3(subunitScale,height,-subunitScale).translate(worldOffset),new vec3(subunitScale,0,-subunitScale).translate(worldOffset),new vec3(-subunitScale,0,-subunitScale).translate(worldOffset),new vec3(1,0,1)));
            
            if(this.queryMaze(i,j,0,1)==0)
            this.quads.push(new quad3(new vec3(subunitScale,height,-subunitScale).translate(worldOffset),new vec3(subunitScale,height,subunitScale).translate(worldOffset),new vec3(subunitScale,0,subunitScale).translate(worldOffset),new vec3(subunitScale,0,-subunitScale).translate(worldOffset),new vec3(1,0,1)));
            
            if(this.queryMaze(i,j,0,-1)==0)
            this.quads.push(new quad3(new vec3(-subunitScale,height,-subunitScale).translate(worldOffset),new vec3(-subunitScale,height,subunitScale).translate(worldOffset),new vec3(-subunitScale,0,subunitScale).translate(worldOffset),new vec3(-subunitScale,0,-subunitScale).translate(worldOffset),new vec3(1,0,1)));
            

         }
      }

      //1,0.5,0.5
   
      this.quads.push(new quad3(new vec3(-subunitScale*size,0,subunitScale*size),new vec3(subunitScale*size,0,subunitScale*size),new vec3(subunitScale*size,0,-subunitScale*size),new vec3(-subunitScale*size,0,-subunitScale*size),new vec3(1,0.5,0.5)));

           //1,0.,0.5 
           this.quads.push(new quad3(new vec3(-subunitScale*size,height,subunitScale*size),new vec3(subunitScale*size,height,subunitScale*size),new vec3(subunitScale*size,height,-subunitScale*size),new vec3(-subunitScale*size,height,-subunitScale*size),new vec3(1,0,0.5 )));


   }
   addSelfToWorld(w){
      this.quads.forEach((q)=>w.addQuad(q))
   }
}
class world{
   fragCode =``;
   uniformSource=''
   uniformsUsed = []
   materialSource=""
   vertOrder = [0,1,2,2,3,0]
   quads=[]
   vertices=[]
   colors=[]
   indices=[]
   materials=[]
   reloadGeometry(gl,vertex_buffer,color_buffer,index_buffer){
        
         this.buildGeometry();
     
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);

         // Create and store data into color buffer
   
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.colors), gl.STATIC_DRAW);

         // Create and store data into index buffer
     
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
   }
   clearGeometry(){
      while(this.vertices.length>0)
         this.vertices.pop();
      while(this.colors.length>0)
         this.colors.pop();
      while(this.indices.length>0)
         this.indices.pop();
      while(this.quads.length>0)
         this.quads.pop();
   }
   clear(){
      while(this.vertices.length>0)
         this.vertices.pop();
      while(this.colors.length>0)
         this.colors.pop();
      while(this.indices.length>0)
         this.indices.pop();
      while(this.uniformsUsed.length>0)
         this.uniformsUsed.pop();
      while(this.quads.length>0)
         this.quads.pop();
      this.fragCode=``;
      this.materialSource='';
      this.uniformSource='';
   }
   addQuad(quad){
      this.quads.push(quad);
   }
   addMaterial(material){
      this.materials.push(material)
   }
   buildGeometry(){
      for(var i =0;i<this.quads.length;i++){
         var quad = this.quads[i];
         
         quad.a.insertSelf(this.vertices);
         quad.color.insertSelf(this.colors);

         quad.b.insertSelf(this.vertices);
         quad.color.insertSelf(this.colors);

         quad.c.insertSelf(this.vertices);
         quad.color.insertSelf(this.colors);

         quad.d.insertSelf(this.vertices);
         quad.color.insertSelf(this.colors);



         
      }

      for(var i=0;i<this.quads.length;i++){
         this.vertOrder.forEach((subIndex)=>this.indices.push(i*4+subIndex))
      }
   }
   build(){
      while(this.vertices.length>0)
         this.vertices.pop();
      while(this.colors.length>0)
         this.colors.pop();
      while(this.indices.length>0)
         this.indices.pop();
         while(this.uniformsUsed.length>0)
         this.uniformsUsed.pop();
      this.fragCode=``;
      this.materialSource='';
      this.uniformSource='';
      var uniformString = '';
      this.materials.forEach((material)=>{

         material.uniforms.forEach((uniform)=>{
            
               if(!this.uniformsUsed.includes(uniform.name)){
                  this.uniformSource+=`\nuniform ${uniform.type} ${uniform.name};\n`;
                  this.uniformsUsed.push(uniform.name)
               }
         })

      })
      
      this.materials.forEach((material)=>{this.materialSource+=material.getFullSource()})

  this.buildGeometry()
      this.fragCode= `precision mediump float;
            varying vec3 vColor;
            varying vec3 worldPos;
            uniform vec3 playerVec;
            uniform float gameTime;
            ${this.uniformSource}
            void main(void) {
               vec3 finalColor=vColor;
${this.materialSource}
               gl_FragColor = vec4(finalColor, 1.);
            }`;
      
   }
   getVertices(){
      return this.vertices;
   }
   getColors(){
      return this.colors;
   }
   getIndices(){
      return this.indices;
   }
   getFragCode(){
      return this.fragCode;
   }

}

class quad3{

    a=new vec3();
    b=new vec3();
    c=new vec3();
    d=new vec3();
    color  = new vec3(1,0,0);

    constructor(a,b,c,d,color){
        if(a instanceof vec3)
            this.a=a;
        if(b instanceof vec3)
            this.b=b;
        if(c instanceof vec3)
            this.c=c;
        if(d instanceof vec3)
            this.d=d;
         if(color instanceof vec3)
            this.color=color;   
    }

    copy(){
        return new quad3(this.a.copy(),this.b.copy(),this.c.copy(),this.d.copy());
    }

    getNormal(){
        return crossProduct(this.d.getDifference(this.a),this.b.getDifference(this.a)).getDirection();
    }

}

class vec3{
    x=0;
    y=0;
    z=0;
    constructor(x,y,z){
        if(typeof x==='number')
            this.x=x;
        if(typeof y==='number')
            this.y=y;
         if(typeof z==='number')
            this.z=z;
    }
   
    copy(){
        return new vec3(this.x,this.y,this.z);
    }
    translate(delta){
        this.x+=delta.x;
        this.y+=delta.y;
        this.z+=delta.z;
        return this;
    }
    scale(scaleFactor){
      this.x*=scaleFactor;
      this.y*=scaleFactor;
      this.z*=scaleFactor;
      return this;
    }

 

    getMagnitude(){
        return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2));
    }

    getDifference(origin){
        return new vec3(this.x-origin.x,this.y-origin.y,this.z-origin.z);
    }

    getDirection(){
        var magnitude=this.getMagnitude();
        return new vec3(this.x/magnitude,this.y/magnitude,this.z/magnitude);
    }

    getAngle(b){
        return Math.acos(dotProduct(this,b)/(this.getMagnitude()*b.getMagnitude()));
    }

    insertSelf(arr){
       arr.push(this.x);
       arr.push(this.y);
       arr.push(this.z);
    }
    ebem(v){
       this.x*=v.x;
       this.y*=v.y;
       this.z*=v.z;
       return this;
    }
    toArray(){
       return [this.x,this.y,this.z];
    }
    
    swizzle(seq){
      var coords = [];
      for(var i=0;i<3;i++){
         switch(seq[i]){
            case 'x': coords.push(this.x); break;
            case 'y': coords.push(this.y); break;
            case 'z': coords.push(this.z); break;
         }
      }
      return new vec3().fromArray(coords);
    }
    fromArray(coords){
       this.x=coords[0];
       this.y=coords[1];
       this.z=coords[2];
       return this;
    }
}
gameWorld = new world();
var sector1;
function loadGame(){
   var materialSource=`
   float tiling=2.;
   float squareVal=mod(floor(mod(worldPos.x,1.)*tiling)+floor(mod(worldPos.y,1.)*tiling)+floor(mod(worldPos.z,1.)*tiling),2.)<0.001?1.:0.;
   float lightVal=(1.-length(worldPos-playerVec)/drawDistance);
   finalColor=squareVal*lightVal*vec3(1.,1.,1.);
   `;

   var material=new material3(materialSource,new vec3(1,0,1),[{type:'float',name:'drawDistance'}]);
   var materialSource2=`
   float tiling=2.;
   float squareVal=mod(floor(mod(worldPos.x,1.)*tiling)+floor(mod(worldPos.y,1.)*tiling)+floor(mod(worldPos.z,1.)*tiling),2.)<0.001?1.:0.;
   float lightVal=(1.-length(worldPos-playerVec)/drawDistance);
   finalColor=squareVal*lightVal*vec3(1.,0.75,0.5);
   `;

   var material2=new material3(materialSource2,new vec3(1,0,0.5),[{type:'float',name:'drawDistance'}]);
   var materialSource3=`
   float tiling=2.;
   float squareVal=mod(floor(mod(worldPos.x,1.)*tiling)+floor(mod(worldPos.y,1.)*tiling)+floor(mod(worldPos.z,1.)*tiling),2.)<0.001?1.:0.;
   float lightVal=(1.-length(worldPos-playerVec)/drawDistance);
   finalColor=squareVal*lightVal*vec3(0.25,0.25,0.5);
   `;

   var myMaterial3=new material3(materialSource3,new vec3(1,0.5,0.5),[{type:'float',name:'drawDistance'}]);


   gameWorld.addMaterial(material);
   gameWorld.addMaterial(material2);
   gameWorld.addMaterial(myMaterial3);
   /*for(var i=-7;i<7;i++){
      for(var j=-7;j<7;j++){
         gameWorld.addQuad(new quad3(new vec3(i*2-1,0,j*2+1),new vec3(i*2+1,0,j*2+1),new vec3(i*2+1,0,j*2-1), new vec3(i*2-1,0,j*2-1),new vec3(1,0,1)));
      }
   }
   gameWorld.addQuad(new quad3(new vec3(0,3,-5),new vec3(0,3,5),new vec3(0,0,5),new vec3(0,0,-5),new vec3(1,0,1)));
   gameWorld.addQuad(new quad3(new vec3(-5,3,0),new vec3(5,3,0),new vec3(5,0,0),new vec3(-5,0,0),new vec3(1,0,1)));*/
   sector1=new mazeMesh(7,[
   
   1,1,1,1,1,1,0,
   1,0,1,0,1,1,1,
   1,0,1,1,1,0,1,
   0,0,1,1,1,0,0,
   1,1,1,1,0,1,0,
   1,0,1,0,1,1,1,
   1,1,1,1,1,0,0
   
   ]);
   sector1.build();
   sector1.addSelfToWorld(gameWorld);
   gameWorld.build();
   document.getElementsByTagName("body")[0].innerHtml="done loading.";
}
document.getElementsByTagName("body")[0].innerHtml="loading...";
loadGame();




         /*============= Creating a canvas =================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');

         /*============ Defining and storing the geometry =========*/

         var vertices = gameWorld.getVertices();

         var colors= gameWorld.getColors();

         var indices=gameWorld.getIndices();

         // Create and store data into vertex buffer
         var vertex_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Create and store data into color buffer
         var color_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

         // Create and store data into index buffer
         var index_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

         /*=================== Shaders =========================*/
         /*
         var vertCode = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute vec3 color;'+//the color of the point
            'varying vec3 vColor;'+

            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vColor = color;'+
            '}';

         var fragCode = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';
*/
var vertCode = `attribute vec3 position;
            uniform mat4 Pmatrix;
            uniform mat4 Vmatrix;
            uniform mat4 Mmatrix;
          
            attribute vec3 color;
            varying vec3 vColor;
            varying vec3 worldPos;

            void main(void) { 
               gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
               worldPos=(Mmatrix*vec4(position, 1.)).zyx;
               vColor = color;
            }`;

        /* var fragCode = `precision mediump float;
            varying vec3 vColor;
            varying vec3 worldPos;
            
            void main(void) {
               float sF= worldPos.x<0.&&worldPos.z<0.?(1.-length(worldPos)/(12.)):1.;
               gl_FragColor = vec4(sF*vColor, 1.);
            }`;*/
            var fragCode=gameWorld.getFragCode();
            console.log(fragCode)
          

         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);
            console.log("vslog")
var message = gl.getShaderInfoLog(vertShader);

if (message.length > 0) {
  /* message may be an error or a warning */
  throw message;
}
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);
         console.log("fslog")
         var message = gl.getShaderInfoLog(fragShader);

if (message.length > 0) {
  /* message may be an error or a warning */
  throw message;
}

         var shaderProgram = gl.createProgram();
         gl.attachShader(shaderProgram, vertShader);
         gl.attachShader(shaderProgram, fragShader);
         gl.linkProgram(shaderProgram);

         /* ====== Associating attributes to vertex shader =====*/
         var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
         var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
         var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");
         var gameTime=gl.getUniformLocation(shaderProgram, "gameTime");
      
         var pVec=gl.getUniformLocation(shaderProgram, "playerVec");
       
     
         var dD=gl.getUniformLocation(shaderProgram,'drawDistance');
      
         

         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         var position = gl.getAttribLocation(shaderProgram, "position");
         gl.vertexAttribPointer(position, 3, gl.FLOAT, false,0,0) ;

         // Position
         gl.enableVertexAttribArray(position);
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         var color = gl.getAttribLocation(shaderProgram, "color");
         gl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0) ;

         // Color
         gl.enableVertexAttribArray(color);
         gl.useProgram(shaderProgram);

         /*==================== MATRIX =====================*/

         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 
            ];
         }

         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);

         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         var playerAngle=0;
         var playerPitch=0;
         var playerVec = new vec3(0,2,0);
         
         function cellChanged(newpXCell,newpZCell){
        
         pXCell=newpXCell;
           pZCell=newpZCell;
            sector1.build();
            gameWorld.clearGeometry();
            sector1.addSelfToWorld(gameWorld);
            gameWorld.reloadGeometry(gl,vertex_buffer,color_buffer,index_buffer);
           
         }
         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

         // translating z
         view_matrix[14] = view_matrix[14]-6;//zoom

         /*==================== Rotation ====================*/

         function translated(m,delta){
            var tMatrix = transposed([1,0,0,delta.x,0,1,0,delta.y,0,0,1,delta.z,0,0,0,1]);
            var result = multMat4sAsArrays(tMatrix,m);
            return result;
         }

         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];

            m[1]=c*m[1]+s*mv0;
            m[5]=c*m[5]+s*mv4;
            m[9]=c*m[9]+s*mv8;
         }

         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];

            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
         }

         function rotateY(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
         }

         /*================= Drawing ===========================*/
         var time_old = 0;

         var animate = function(time) {
            var newpXcell = Math.floor((playerVec.x+5)/10.0);
            var newpZcell = Math.floor((playerVec.z+5)/10.0);
            if(newpXcell!=pXCell||newpZcell!=pZCell){
               cellChanged(newpXcell,newpZcell);
            }
            view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            var dt = time-time_old;
           // rotateZ(mov_matrix, dt*0.005);//time
        if(isKeyDown(Keys.left))
            playerAngle+=dt*0.006;
            if(isKeyDown(Keys.right))
            playerAngle-=dt*0.006;
    

        
            if(isKeyDown(Keys.up))
            playerPitch+=dt*0.006;
            if(isKeyDown(Keys.down))
            playerPitch-=dt*0.006;

            if(playerPitch>Math.PI/6)
            playerPitch=Math.PI/6

            if(playerPitch<-Math.PI/6)
            playerPitch=-Math.PI/6

            if(isKeyDown(Keys.w))
            playerVec.translate(new vec3(dt*0.01*Math.cos(playerAngle),0,dt*0.01*Math.sin(playerAngle)))
            if(isKeyDown(Keys.a))
            playerVec.translate(new vec3(-dt*0.01*Math.sin(playerAngle),0,dt*0.01*Math.cos(playerAngle)))
            if(isKeyDown(Keys.s))
            playerVec.translate(new vec3(dt*0.01*Math.cos(playerAngle),0,dt*0.01*Math.sin(playerAngle)).scale(-1))
            if(isKeyDown(Keys.d))
            playerVec.translate(new vec3(-dt*0.01*Math.sin(playerAngle),0,dt*0.01*Math.cos(playerAngle)).scale(-1))
            rotateY(view_matrix, -(playerAngle-Math.PI));
            
            rotateX(view_matrix,-playerPitch)
            view_matrix=translated(view_matrix,new vec3(playerVec.z,playerVec.y,playerVec.x).scale(-1));
          
            time_old = time;

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0,0,0,1);
            gl.clearDepth(1.0);

            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);
            gl.uniform3fv(pVec,playerVec.toArray());
            gl.uniform1f(gameTime,time);
            gl.uniform1f(dD,30);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
           
            window.requestAnimationFrame(animate);
         }
         animate(0);
      </script>
   </body>
</html>
